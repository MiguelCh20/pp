#!/usr/bin/env python
# -*- coding: UTF-8 -*-
#
# generated by wxGlade 0.9.5 on Sat Apr 18 15:40:29 2020
#
import wx.lib.agw.shapedbutton as SB
import wx
import random
import copy

# begin wxGlade: dependencies
# end wxGlade

# begin wxGlade: extracode
# end wxGlade


diccionario_2048 = {"A": "3-1.png", "B": "3-2.png", "C": "3-3.png", "D": "3-4.png", "E": "3-5.png", "F": "3-6.png",
                    "G": "3-7.png", "H": "3-8.png", "I": "3-9.png",
                    "J": "3-10.png",
                    "K": "3-11.png", ".": "Vacio.png", "*": "Bloque.png"}
diccionario_1024 = {"A": "2-1.png", "B": "2-2.png", "C": "2-3.png", "D": "2-4.png", "E": "2-5.png", "F": "2-6.png",
                    "G": "2-7.png", "H": "2-8.png", "I": "2-9.png",
                    "J": "2-10.png",
                    "K": "2-11.png", ".": "Vacio.png", "*": "Bloque.png"}
diccionario_abc = {"A": "0-1.png", "B": "0-2.png", "C": "0-3.png", "D": "0-4.png", "E": "0-5.png", "F": "0-6.png",
                   "G": "0-7.png", "H": "0-8.png", "I": "0-9.png",
                   "J": "0-10.png",
                   "K": "0-11.png", ".": "Vacio.png", "*": "Bloque.png"}
diccionario_nivel = {"A": "1-1.png", "B": "1-2.png", "C": "1-3.png", "D": "1-4.png", "E": "1-5.png", "F": "1-6.png",
                     "G": "1-7.png", "H": "1-8.png", "I": "1-9.png",
                     "J": "1-10.png",
                     "K": "1-11.png", ".": "Vacio.png", "*": "Bloque.png"}

diccionario_puntos = {"B": "2", "C": "3", "D": "4", "E": "5", "F": "6", "G": "7", "H": "8", "I": "9",
                      "J": "10", "K": "11"}

diccionario_fusión = {"A": "B", "B": "C", "C": "D", "D": "E", "E": "F", "F": "G", "G": "H", "H": "I", "I": "J",
                      "J": "K"}


class MyDialog(wx.Dialog):
    """"""

    #----------------------------------------------------------------------
    def __init__(self):
        """Constructor"""
        wx.Dialog.__init__(self, None, title="Datos Matriz")

        self.comboBox1 = wx.SpinCtrl(self, wx.ID_ANY, "")
        self.comboBox2 = wx.SpinCtrl(self, wx.ID_ANY, "")
        okBtn = wx.Button(self, wx.ID_OK)
        label_1 = wx.StaticText(self, wx.ID_ANY, "DIMENSIÓN MATRIZ:")
        label_2 = wx.StaticText(self, wx.ID_ANY, "Nº BLOQUES:")

        sizer = wx.BoxSizer(wx.VERTICAL)
        sizer.Add(label_1, 0, wx.ALL|wx.CENTER, 5)
        sizer.Add(self.comboBox1, 0, wx.ALL|wx.CENTER, 2)
        sizer.Add(label_2, 0, wx.ALL|wx.CENTER,5)
        sizer.Add(self.comboBox2, 0, wx.ALL|wx.CENTER, 2)
        sizer.Add(okBtn, 0, wx.ALL|wx.CENTER, 2)
        self.SetSizer(sizer)


class MiVentana(wx.Frame):
    matriz = []
    
    def __init__(self, *args, **kwds):
        # begin wxGlade: MiVentana.__init__
        kwds["style"] = kwds.get("style", 0) | wx.DEFAULT_FRAME_STYLE
        wx.Frame.__init__(self, *args, **kwds)
        self.SetSize((1299, 668))
        self.newsheet_button = wx.BitmapButton(self, wx.ID_ANY, wx.Bitmap("newsheet.ico", wx.BITMAP_TYPE_ICO))
        self.open_button = wx.BitmapButton(self, wx.ID_ANY, wx.Bitmap("abrir.ico", wx.BITMAP_TYPE_ICO))
        self.save_button = wx.BitmapButton(self, wx.ID_ANY, wx.Bitmap("save.ico", wx.BITMAP_TYPE_ICO))
        self.undo_button = wx.BitmapButton(self, wx.ID_ANY, wx.Bitmap("undo.ico", wx.BITMAP_TYPE_ICO))
        self.radio_btn_2048 = wx.RadioButton(self, wx.ID_ANY, "")
        self.radio_btn_abc = wx.RadioButton(self, wx.ID_ANY, "")
        self.radio_btn_nivel = wx.RadioButton(self, wx.ID_ANY, "")
        self.radio_btn_1024 = wx.RadioButton(self, wx.ID_ANY, "")
        self.matrix = wx.Panel(self, wx.ID_ANY)
        self.matrix.Bind(wx.EVT_CHAR_HOOK, self.mover)

        # AQUI SE CREA LA PRIMERA MATRIZ
        self.size = 4
        self.obstaculos = 2
        z = 0
        l = 0
        for i in range(self.size):
            self.matriz.append([" "] * self.size)
        while z < self.obstaculos:
            rand_r = random.randint(0, self.size - 1)
            rand_c = random.randint(0, self.size - 1)
            if self.matriz[rand_r][rand_c] == " ":
                self.matriz[rand_r][rand_c] = diccionario_2048["*"]
                z = z + 1
        while l < 2:
            rand_r = random.randint(0, self.size - 1)
            rand_c = random.randint(0, self.size - 1)
            if self.matriz[rand_r][rand_c] != diccionario_2048["*"]:
                self.matriz[rand_r][rand_c] = diccionario_2048["A"]
                l = l + 1
        for r in range(self.size):
            for c in range(self.size):
                if self.matriz[r][c] == " ":
                    self.matriz[r][c] = diccionario_2048["."]

        self.diccionario_antiguo = diccionario_2048
        self.puntos = 0
        self.movimientos = 0
        
        self.__set_properties()
        self.__do_layout()

        
        self.Bind(wx.EVT_BUTTON, self.OnBtnSave, self.save_button)
        self.Bind(wx.EVT_BUTTON, self.OnBtnNewMatrix, self.newsheet_button)
        self.Bind(wx.EVT_BUTTON, self.OnBtnUndo, self.undo_button)
        self.Bind(wx.EVT_BUTTON, self.OnBtnOpen, self.open_button)
        self.Bind(wx.EVT_RADIOBUTTON, self.OnBtnDic2048, self.radio_btn_2048)
        self.Bind(wx.EVT_RADIOBUTTON, self.OnBtnDic1024, self.radio_btn_1024)
        self.Bind(wx.EVT_RADIOBUTTON, self.OnBtnDicNivel, self.radio_btn_nivel)
        self.Bind(wx.EVT_RADIOBUTTON, self.OnBtnDicABC, self.radio_btn_abc)
        
        # end wxGlade



    def Matrix(self):
        for i in range(3):
            self.matriz.append([" "] * 3)
        while i < 2:
            rand_r = random.randint(0, 3 - 1)
            rand_c = random.randint(0, 3 - 1)
            if self.matriz[rand_r][rand_c] == " ":
                self.matriz[rand_r][rand_c] = diccionario_2048["*"]
        while i < 2:
            rand_r = random.randint(0, 3 - 1)
            rand_c = random.randint(0, 3 - 1)
            if self.matriz[rand_r][rand_c] != diccionario_2048["*"]:
                self.matriz[rand_r][rand_c] = diccionario_2048["A"]
        for i in range(3):
            for j in range(3):
                if self.matriz[i][j] == " ":
                    self.matriz[i][j] = diccionario_2048["."]
        return self.matriz
    

    def __set_properties(self):
        # begin wxGlade: MiVentana.__set_properties
        self.SetTitle("2048")
        self.SetBackgroundColour(wx.Colour(255, 255, 255))
        self.newsheet_button.SetBackgroundColour(wx.Colour(255, 255, 255))
        self.newsheet_button.SetSize(self.newsheet_button.GetBestSize())
        
        self.open_button.SetBackgroundColour(wx.Colour(255, 255, 255))
        self.open_button.SetSize(self.open_button.GetBestSize())
        self.save_button.SetBackgroundColour(wx.Colour(255, 255, 255))
        self.save_button.SetSize(self.save_button.GetBestSize())
        self.undo_button.SetBackgroundColour(wx.Colour(255, 255, 255))
        self.undo_button.SetSize(self.undo_button.GetBestSize())
        self.radio_btn_2048.SetValue(1)
        self.radio_btn_nivel.SetFont(
            wx.Font(9, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL, 0, "Segoe UI"))
        self.matrix.SetMinSize((700, 700))
        self.matrix.SetBackgroundColour(wx.Colour("black"))
        # end wxGlade

    def __do_layout(self):
        # begin wxGlade: MiVentana.__do_layout
        sizer_4 = wx.BoxSizer(wx.VERTICAL)
        grid_sizer_5 = wx.GridSizer(1, 2, 0, 0)
        sizer_16 = wx.BoxSizer(wx.HORIZONTAL)
        grid_sizer_3 = wx.GridSizer(3, 3, 0, 0)
        sizer_6 = wx.BoxSizer(wx.VERTICAL)
        sizer_7 = wx.BoxSizer(wx.HORIZONTAL)
        sizer_14 = wx.StaticBoxSizer(wx.StaticBox(self, wx.ID_ANY, "MODO"), wx.HORIZONTAL)
        grid_sizer_2 = wx.GridSizer(4, 2, 0, 0)
        sizer_8 = wx.BoxSizer(wx.VERTICAL)
        sizer_9 = wx.StaticBoxSizer(wx.StaticBox(self, wx.ID_ANY, u"INFORMACIÓN"), wx.HORIZONTAL)
        sizer_15 = wx.BoxSizer(wx.HORIZONTAL)
        sizer_1 = wx.BoxSizer(wx.VERTICAL)
        grid_sizer_1 = wx.GridSizer(1, 4, 0, 0)
        sizer_13 = wx.BoxSizer(wx.VERTICAL)
        sizer_12 = wx.BoxSizer(wx.VERTICAL)
        sizer_11 = wx.BoxSizer(wx.VERTICAL)
        sizer_10 = wx.BoxSizer(wx.VERTICAL)
        sizer_10.Add(self.newsheet_button, 1, wx.ALIGN_CENTER | wx.ALL , 14)
        sizer_10.Add((0, 0), 0, 0, 0)
        grid_sizer_1.Add(sizer_10, 0, wx.EXPAND, 0)
        sizer_11.Add(self.open_button, 1, wx.ALIGN_CENTER | wx.ALL , 14)
        sizer_11.Add((0, 0), 0, 0, 0)
        grid_sizer_1.Add(sizer_11, 0, wx.EXPAND, 0)
        sizer_12.Add(self.save_button, 1, wx.ALIGN_CENTER | wx.ALL , 14)
        sizer_12.Add((0, 0), 0, 0, 0)
        grid_sizer_1.Add(sizer_12, 0, wx.EXPAND, 0)
        sizer_13.Add(self.undo_button, 1, wx.ALIGN_CENTER | wx.ALL , 14)
        sizer_13.Add((0, 0), 0, 0, 0)
        grid_sizer_1.Add(sizer_13, 0, wx.EXPAND, 0)
        sizer_8.Add(grid_sizer_1, 0, wx.EXPAND, 0)
        label_2 = wx.StaticText(self, wx.ID_ANY, "AUTORES:\nMIGUEL Y ABDU")
        label_2.SetFont(wx.Font(10, wx.DEFAULT, wx.NORMAL, wx.NORMAL, 0, "Segoe UI"))
        sizer_15.Add(label_2, 1, 0, 0)
        self.label_movs = wx.StaticText(self, wx.ID_ANY, "MOVIMIENTOS: 0")
        self.label_movs.SetFont(wx.Font(10, wx.DEFAULT, wx.NORMAL, wx.NORMAL, 0, "Segoe UI"))
        sizer_1.Add(self.label_movs, 1, wx.ALIGN_CENTER | wx.ALL,0)
        self.label_puntos = wx.StaticText(self, wx.ID_ANY, "PUNTOS:0", style=wx.ALIGN_LEFT)
        self.label_puntos.SetFont(wx.Font(10, wx.DEFAULT, wx.NORMAL, wx.NORMAL, 0, "Segoe UI"))
        sizer_1.Add(self.label_puntos, 1, wx.ALIGN_CENTER | wx.ALL, 0)
        sizer_15.Add(sizer_1, 1, wx.EXPAND, 0)
        sizer_9.Add(sizer_15, 1, wx.EXPAND, 0)
        sizer_8.Add(sizer_9, 0, wx.EXPAND, 0)
        sizer_6.Add(sizer_8, 0, wx.EXPAND, 0)
        label_2048 = wx.StaticText(self, wx.ID_ANY, "2048", style=wx.ALIGN_CENTER)
        label_2048.SetFont(wx.Font(16, wx.DEFAULT, wx.NORMAL, wx.NORMAL, 0, "Segoe UI"))
        grid_sizer_2.Add(label_2048, 1, wx.ALIGN_CENTER | wx.ALL , 20)
        grid_sizer_2.Add(self.radio_btn_2048, 1, wx.ALIGN_CENTER | wx.ALL , 10)
        label_abc = wx.StaticText(self, wx.ID_ANY, "ABC")
        label_abc.SetFont(wx.Font(16, wx.DEFAULT, wx.NORMAL, wx.NORMAL, 0, "Segoe UI"))
        grid_sizer_2.Add(label_abc, 1, wx.ALIGN_CENTER | wx.ALL , 20)
        grid_sizer_2.Add(self.radio_btn_abc, 0, wx.ALIGN_CENTER , 0)
        label_nivel = wx.StaticText(self, wx.ID_ANY, "NIVEL")
        label_nivel.SetFont(wx.Font(16, wx.DEFAULT, wx.NORMAL, wx.NORMAL, 0, "Segoe UI"))
        grid_sizer_2.Add(label_nivel, 1, wx.ALIGN_CENTER | wx.ALL , 20)
        grid_sizer_2.Add(self.radio_btn_nivel, 0, wx.ALIGN_CENTER | wx.ALL , 0)
        label_1024 = wx.StaticText(self, wx.ID_ANY, "1024")
        label_1024.SetFont(wx.Font(16, wx.DEFAULT, wx.NORMAL, wx.NORMAL, 0, "Segoe UI"))
        grid_sizer_2.Add(label_1024, 1, wx.ALIGN_CENTER | wx.ALL , 20)
        grid_sizer_2.Add(self.radio_btn_1024, 0, wx.ALIGN_CENTER | wx.ALL , 0)
        sizer_14.Add(grid_sizer_2, 1, wx.EXPAND, 0)
        sizer_7.Add(sizer_14, 1, wx.ALL | wx.EXPAND, 0)
        sizer_6.Add(sizer_7, 1, wx.EXPAND, 0)
        grid_sizer_5.Add(sizer_6, 0, wx.EXPAND, 0)
        grid_sizer_3 = wx.GridSizer(self.size, self.size, 0, 0)

        Matriz.ImprimirTablero(self, sizer_16, grid_sizer_3, grid_sizer_5, self.matriz)

        sizer_4.Add(grid_sizer_5, 1, wx.EXPAND, 0)

        self.SetSizer(sizer_4)
        self.Layout()
        # end wxGlade

        
    def OnBtnNewMatrix(self, event):  # wxGlade: MyFrame.<event_handler
        """"""
        dlg = MyDialog()
        res = dlg.ShowModal()
        if res == wx.ID_OK:
            self.size=dlg.comboBox1.GetValue()
            self.obstaculos=dlg.comboBox2.GetValue()
        dlg.Destroy()


    def mover(self, event):
        self.matriz_previa = copy.deepcopy(self.matriz)  # copiamos la matriz antes de realizar el movimiento
        self.puntos_previos = self.puntos
        codigo_tecla = event.GetKeyCode()
        if codigo_tecla == wx.WXK_UP:
            self.inp = "S"
            self.moverTablero()
        elif codigo_tecla == wx.WXK_DOWN:
            self.inp = "B"
            self.moverTablero()
        elif codigo_tecla == wx.WXK_LEFT:
            self.inp = "I"
            self.moverTablero()
        elif codigo_tecla == wx.WXK_RIGHT:
            self.inp = "D"
            self.moverTablero()

    def moverTablero(self):
        if self.inp == "S" or self.inp == "B" or self.inp == "I" or self.inp == "D":
            matriz_comparar = copy.deepcopy(self.matriz)  # copiamos la matriz antes de realizar el movimiento
            Matriz.eleccion(self, self.matriz,
                            self.inp)  # llamamos a la funcion que nos realizara todo aquello referente al movimiento
            igual = Matriz.comparar(self, self.matriz, matriz_comparar,
                                    self.size)  # llamamos a la funcion comparar que nos dira si la matriz anterior y la actual son iguales
            if igual:
                movimientos_str = str("MOVIMIENTOS: " + str(self.movimientos))
                self.label_movs.SetLabelText(movimientos_str)
            else:
                self.matriz = Matriz.new_values(self, self.matriz, self.diccionario_antiguo,
                                                self.size)  # si  no es igual introducimos tras el movimiento un nuevo valor aleatorio entre 2 y 4 en una posicio
                self.movimientos = self.movimientos + 1
                movimientos_str = str("MOVIMIENTOS: " + str(self.movimientos))
                self.label_movs.SetLabelText(movimientos_str)
                sizer_16 = wx.GridSizer(0, 0, 0, 0)
                grid_sizer_3 = wx.GridSizer(self.size, self.size, 0, 0)
                grid_sizer_5 = wx.GridSizer(1, 2, 0, 0)

                Matriz.ImprimirTablero(self, sizer_16, grid_sizer_3, grid_sizer_5, self.matriz)


    def OnBtnOpen(self, event):  # wxGlade: MyFrame.<event_handler>
        r = -1
        print("poner dialogo aqui, abrir, lectura y generacion de matriz")
        direccion = wx.FileDialog(self, "Cargar partida", wildcard="Archivo .txt (*.txt)|*.txt",
                                  style=wx.FD_OPEN)

        if direccion.ShowModal() == wx.ID_CANCEL:
            return
        partida = open(direccion.GetPath(), "r+")
        self.size = int(partida.readline())
        self.movimientos = int(partida.readline())
        movimientos_str = str("MOVIMIENTOS: " + str(self.movimientos))
        self.label_movs.SetLabelText(movimientos_str)
        self.puntos = int(partida.readline())
        puntos_str = str("PUNTOS: " + str(self.puntos))
        self.label_puntos.SetLabelText(puntos_str)

        for i in range(self.size):
            self.matriz.append([" "] * self.size)

        for position, line in enumerate(partida):

            r += 1

            for c in range(self.size):
                char = line[c]

                self.matriz[r][c] = diccionario_2048[char]

        partida.close()
        self.diccionario_antiguo = diccionario_2048
        sizer_16 = wx.GridSizer(0, 0, 0, 0)
        grid_sizer_3 = wx.GridSizer(self.size, self.size, 0, 0)
        grid_sizer_5 = wx.GridSizer(1, 2, 0, 0)
        Matriz.ImprimirTablero(self, sizer_16, grid_sizer_3, grid_sizer_5, self.matriz)


    def OnBtnSave(self, event):  # wxGlade: MyFrame.<event_handler>
        fileDialog = wx.FileDialog(self, "Guardar partida", wildcard="Archivo .txt (*.txt)|*.txt",
                                   style=wx.FD_SAVE | wx.FD_OVERWRITE_PROMPT)

        if fileDialog.ShowModal() == wx.ID_CANCEL:
            return
        nombre_usr = fileDialog.GetPath()
        try:
            archivo = open(nombre_usr, 'w+')
            archivo.write(str(self.size))
            archivo.write("\n")
            archivo.write(str(self.movimientos))
            archivo.write("\n")
            archivo.write(str(self.puntos))
            archivo.write("\n")
            for r in range(self.size):
                for c in range(self.size):

                    clave = [key for key, value in self.diccionario_antiguo.items() if
                             value == self.matriz[r][c]]  # RETURN DE KEY A PARTIR DE VALOR
                    archivo.write(clave[0])

                    if c == self.size - 1:
                        archivo.write("\n")

            archivo.close()
        except IOError:
            wx.LogError("No se puede guardar aqui: '%s'." % nombre_usr)

    def OnBtnUndo(self, event):  # wxGlade: MyFrame.<event_handler>
        print("guardar ultima matriz y en caso de pulsarlo, imprimir esta.")
        self.matriz = self.matriz_previa
        self.puntos = self.puntos_previos
        self.movimientos = self.movimientos - 1
        movimientos_str = str("MOVIMIENTOS: " + str(self.movimientos))
        self.label_movs.SetLabelText(movimientos_str)

        puntos_str = str("PUNTOS: " + str(self.puntos))
        self.label_puntos.SetLabelText(puntos_str)

        sizer_16 = wx.GridSizer(0, 0, 0, 0)
        grid_sizer_3 = wx.GridSizer(self.size, self.size, 0, 0)
        grid_sizer_5 = wx.GridSizer(1, 2, 0, 0)
        Matriz.ImprimirTablero(self, sizer_16, grid_sizer_3, grid_sizer_5, self.matriz)



    def OnBtnDic2048(self, event):  # wxGlade: MyFrame.<event_handler>
        print("if true cambiar bloques a 2048")
        diccionario_nuevo = diccionario_2048

        self.cambiar_diccionario(diccionario_nuevo)
        sizer_16 = wx.GridSizer(0, 0, 0, 0)
        grid_sizer_3 = wx.GridSizer(self.size, self.size, 0, 0)
        grid_sizer_5 = wx.GridSizer(1, 2, 0, 0)
        self.diccionario_antiguo = diccionario_2048

        Matriz.ImprimirTablero(self, sizer_16, grid_sizer_3, grid_sizer_5, self.matriz)


    def OnBtnDic1024(self, event):  # wxGlade: MyFrame.<event_handler>
        print("if true cambiar bloques a 1024")
        diccionario_nuevo = diccionario_1024
        self.cambiar_diccionario(diccionario_nuevo)
        sizer_16 = wx.GridSizer(0, 0, 0, 0)
        grid_sizer_3 = wx.GridSizer(self.size, self.size, 0, 0)
        grid_sizer_5 = wx.GridSizer(1, 2, 0, 0)
        self.diccionario_antiguo = diccionario_1024

        Matriz.ImprimirTablero(self, sizer_16, grid_sizer_3, grid_sizer_5, self.matriz)

    def OnBtnDicNivel(self, event):  # wxGlade: MyFrame.<event_handler>
        print("if true cambiar bloques a nivel")

        diccionario_nuevo = diccionario_nivel

        self.cambiar_diccionario(diccionario_nuevo)
        sizer_16 = wx.GridSizer(0, 0, 0, 0)
        grid_sizer_3 = wx.GridSizer(self.size, self.size, 0, 0)
        grid_sizer_5 = wx.GridSizer(1, 2, 0, 0)
        self.diccionario_antiguo = diccionario_nivel

        Matriz.ImprimirTablero(self, sizer_16, grid_sizer_3, grid_sizer_5, self.matriz)

    def OnBtnDicABC(self, event):  # wxGlade: MyFrame.<event_handler>
        print("if true cambiar bloques a ABC")
        diccionario_nuevo = diccionario_abc

        self.matriz = self.cambiar_diccionario(diccionario_nuevo)
        sizer_16 = wx.GridSizer(0, 0, 0, 0)
        grid_sizer_3 = wx.GridSizer(self.size, self.size, 0, 0)
        grid_sizer_5 = wx.GridSizer(1, 2, 0, 0)
        self.diccionario_antiguo = diccionario_abc

        Matriz.ImprimirTablero(self, sizer_16, grid_sizer_3, grid_sizer_5, self.matriz)

    def cambiar_diccionario(self, diccionario_nuevo):
        for r in range(self.size):
            for c in range(self.size):
                if self.matriz[r][c] != " ":
                    clave = [key for key, value in self.diccionario_antiguo.items() if
                             value == self.matriz[r][c]]  # RETURN DE KEY A PARTIR DE VALOR
                    asignar = clave[0]
                    self.matriz[r][c] = diccionario_nuevo[asignar]
        return self.matriz


class Matriz(MiVentana):

    def __init__(self):
        self.matrix = wx.Panel(self, wx.ID_ANY)
        self.matriz = []
        self.__set_properties()
        self.__do_layout()

    def ImprimirTablero(self, sizer_16, grid_sizer_3, grid_sizer_5,matriz):

        for r in range(self.size):
            for c in range(self.size):
                bitmap = wx.StaticBitmap(self.matrix, wx.ID_ANY, wx.Bitmap(matriz[r][c], wx.BITMAP_TYPE_ANY))
                grid_sizer_3.Add(bitmap, 0, wx.ALIGN_CENTRE, 0)
        sizer_16.Add(grid_sizer_3, 1, wx.EXPAND, 0)
        self.matrix.SetSizer(sizer_16)
        grid_sizer_5.Add(self.matrix, 1, wx.ALIGN_CENTER, 20)
        self.matrix.Layout()

    def new_values(self, matriz, diccionario_actual, size):
        """ Docstring
        :param matriz: Recibimos una matriz de la cual debemos verificar la existencia de un espacio disponible e insertar
        un nuevo bloque.
        :param diccionario_actual: Necesitamos el diccionario actual para poder insertar los bloques correspondientes
        al modo de juego que esta jugando el usuario.
        :param mat_size: Tamano de matriz para poder recorrerla.

        :arg Recibimos una matriz y nos ayudamos de un booleano en este caso val_in, lo utilizamos como condicion en un bucle
        while para asegurar que hemos podido calcular una posicion aleatoria y vacia y hemos insertado el nuevo bloque, con las
        probabilidades correspondientes.


        :return: matriz: Devolvemos una matriz con un nuevo bloque insertado.
        """
        val_in = False
        select_val = random.random()
        if select_val <= 0.75:
            new_val = diccionario_actual["A"]
        else:
            new_val = diccionario_actual["B"]
        while val_in != True:
            rrand = random.randint(0, size - 1)
            crand = random.randint(0, size - 1)
            if matriz[rrand][crand] == diccionario_actual["."]:
                matriz[rrand][crand] = new_val
                val_in = True
        return matriz

    """
     Este metodo nos permitira guardar en una lista las posiciones donde tenemos un "*"
     Parametros de entrada:cadena donde buscar,parametro a buscar
     Parametros de salida: lista que indica el/los lugares(fila o columna) del "*"
    """

    def eleccion(self, matriz, inp):
        matriz_auxiliar = [[0 for columna in range(self.size)] for fila in range(self.size)]
        for r in range(self.size):
            for c in range(self.size):
                clave = [key for key, value in self.diccionario_antiguo.items() if
                         value == self.matriz[r][c]]  # RETURN DE KEY A PARTIR DE VALOR
                asignar = clave[0]
                matriz_auxiliar[r][c] = asignar
        if inp == "I" or inp == "D":
            for r in range(self.size):
                lista = []
                for c in range(self.size):
                    list1 = str(matriz_auxiliar[r][c])
                    list1 = list1.replace(".", " ")
                    lista.append(list1)
                str1 = ''.join(lista)
                lugar = Matriz.encontrar(self, str1, "*")
                Matriz.movimiento(self, self.matriz, self.size, inp, str1, lugar, r, c)

        else:
            for r in range(self.size):
                lista = []
                for c in range(self.size):
                    list1 = str(matriz_auxiliar[c][r])
                    list1 = list1.replace(".", " ")
                    lista.append(list1)
                str1 = ''.join(lista)
                lugar = Matriz.encontrar(self, str1, "*")
                Matriz.movimiento(self, self.matriz, self.size, inp, str1, lugar, r, c)

    """
     Este metodo nos permitira recorrer la matriz según el movimiento e ir guardando en un string cada fila o columna
     correspondiente.Ademas sumamos un movimiento y llamamos a cambiar diccionario para segun el modo en el que estemos
     pasemos de forma indirecta al modo alfabeto con el que trabajaremos para los movimientos. Posteriormente llamamos
     una vez que tenemos la cadena a la funcion movimiento.
     Parametros de entrada:matriz, tamano matriz, orden de movimiento,diccionario actual,diccionario de nivel
     Salida: descarga en la funcion movimiento el control
    """

    def encontrar(self, entrada, busqueda):
        l1 = []
        length = len(entrada)
        index = 0
        while index < length:
            i = entrada.find(busqueda, index)
            if i == -1:
                return l1
            l1.append(i)
            index = i + 1
        return l1

    def movimiento(self, matriz, size, inp, str1, lugar, r, c, ):
        if inp == "S" or inp == "I":
            if len(lugar) == 0:
                cadena = str1.replace(" ", "")
                nuevacad = Matriz.arriba_y_izquierda(self, cadena)
                fincad = nuevacad.replace(" ", "")
                Matriz.nueva_matriz(self, self.matriz, self.size, lugar, fincad, inp, r, c, 0)
            else:
                a = str1.split("*")
                i = 0
                cont = 0
                while i < len(a):
                    if a[i] != "":
                        cadena = a[i].replace(" ", "")
                        nuevacad = Matriz.arriba_y_izquierda(self, cadena)
                        fincad = nuevacad.replace(" ", "")
                        Matriz.nueva_matriz(self, self.matriz, self.size, lugar, fincad, inp, r, i, cont)
                        cont = cont + 1
                    i = i + 1

        elif inp == "B" or inp == "D":
            if len(lugar) == 0:
                cadena = str1.replace(" ", "")
                nuevacad = Matriz.abajo_y_derecha(self, cadena)
                fincad = nuevacad.replace(" ", "")
                Matriz.nueva_matriz(self, self.matriz, self.size, lugar, fincad, inp, r, c, 0)
            else:
                a = str1.split("*")
                i = 0
                cont = 0
                while i < len(a):
                    if a[i] != "":
                        cadena = a[i].replace(" ", "")
                        nuevacad = Matriz.abajo_y_derecha(self, cadena)
                        fincad = nuevacad.replace(" ", "")
                        Matriz.nueva_matriz(self, self.matriz, self.size, lugar, fincad, inp, r, i, cont)
                        cont = cont + 1
                    i = i + 1

    """
     Este metodo nos permitira trabajar con el string y moldearle como nosotros queremos. Primero analizamos según el tipo
     de movimiento y posteriormente si hemos detectado algun * que se encontraran en lugar.Si no detectamos ninguno, quitamos
     los espacios en blanco, llamamos a la funcion que realiza el movimiento y la fusion y posteriormente volvemos a quitar
     los espacios en blanco y llamamos a nueva matriz que nos genera la matriz resultante. Si hay algun * debemos hacer un paso
     previo de comprobacion si en a hay algun "" que nos indicaria que ha habido dos asteriscos juntos y creamos en este caso
     otro contador que nos indicarian las cadenas que en realidad contienen datos
     Parametros de entrada:matriz, tamano matriz, orden de movimiento,diccionario actual,cadena recibida, lista del lugar
     de los "*" ,contadores de filas y columnas de recorrer la matriz y el diccionario nivel que lo utilizaremos para los puntos.
     Salida: descarga en la funcion nueva_matriz el control que nos proporciona la matriz resultante.
    """

    def abajo_y_derecha(self, cadrecibida):
        cadlista = list(cadrecibida)
        puntero = len(cadlista) - 1
        if len(cadlista) != 1:
            while puntero > 0:
                if cadlista[puntero] == cadlista[puntero - 1]:
                    cadlista[puntero - 1] = " "
                    nueva = diccionario_fusión[cadlista[puntero]]
                    cadlista[puntero] = str(nueva)
                    pun_ganados = int(diccionario_puntos[nueva])
                    self.puntos = self.puntos + pun_ganados
                    puntos_str = str("PUNTOS: " + str(self.puntos))
                    self.label_puntos.SetLabelText(puntos_str)

                puntero = puntero - 1

        cadena = ''.join(cadlista)
        return cadena

    """
     En este metodo pasamos a una lista la cadena recibida para poder recorrerla y mutarla. Esta al ser la estructura de abajo y derecha
     lo que hacemos es recorrerla de atras hacia delante y miramos si los valores del puntero y el anterior son iguales para
     proceder a su fusion. Si esto sucede mediante el diccionario de nivel accedemos al valor de lo que vale la letra(ya que hemos convertido
     el diccionario actual al diccionario abc para poder trabajar el movimiento) y con esto sumamos los puntos y conseguidos que la fusion
     se lleve acabo.Por ultimo juntamos en un string toda la lista.
     Parametros de entrada:el string sin espacios y el diccionario de nivel.
     Salida: retorna el string ya fusionado.
    """

    def arriba_y_izquierda(self, cadrecibida):
        cadlista = list(cadrecibida)
        puntero = len(cadlista) - 1
        i = 0
        while i < puntero:
            if cadlista[i] == cadlista[i + 1]:
                cadlista[i + 1] = " "
                nueva = diccionario_fusión[cadlista[i]]
                cadlista[i] = str(nueva)
                pun_ganados = int(diccionario_puntos[nueva])
                self.puntos = self.puntos + pun_ganados
                puntos_str = str("PUNTOS: " + str(self.puntos))
                self.label_puntos.SetLabelText(puntos_str)

            i = i + 1

        cadena = ''.join(cadlista)
        return cadena

    # Mismo procedimiento ya comentado en la funcion abajo y derecha. Solo que en este caso empezamos a analizar la
    # cadena de alante hacia atras hasta la longitud maxima de la cadena.

    def nueva_matriz(self, matriz, size, lugar, fincad, inp, pos, cont, bucle):
        if inp == "S":
            if bucle == 0:
                for r in range(size):
                    matriz[r][pos] = self.diccionario_antiguo["."]
            for r in range(len(lugar)):
                matriz[lugar[r]][pos] = self.diccionario_antiguo["*"]
            if len(lugar) == 0:
                for i in range(len(fincad)):
                    matriz[i][pos] = self.diccionario_antiguo[fincad[i]]
            else:
                if bucle == 0:
                    contador = 0
                    while matriz[0 + contador][pos] == self.diccionario_antiguo["*"]:
                        contador = contador + 1
                    for i in range(len(fincad)):
                        matriz[contador + i][pos] = self.diccionario_antiguo[fincad[i]]
                else:
                    contador = 0
                    while matriz[lugar[cont - 1] + contador][pos] == self.diccionario_antiguo["*"]:
                        contador = contador + 1
                    for i in range(len(fincad)):
                        matriz[lugar[cont - 1] + contador + i][pos] = self.diccionario_antiguo[fincad[i]]

        elif inp == "B":
            if bucle == 0:
                for r in range(size):
                    matriz[r][pos] = self.diccionario_antiguo["."]
            for r in range(len(lugar)):
                matriz[lugar[r]][pos] = self.diccionario_antiguo["*"]
            if len(lugar) == 0:
                for i in range(len(fincad)):
                    self.matriz[self.size - 1 - i][pos] = self.diccionario_antiguo[fincad[len(fincad) - 1 - i]]
            else:
                if bucle == 0:
                    if lugar[0] == 0:
                        contador = 0
                        while matriz[0 + contador][pos] == self.diccionario_antiguo["*"]:
                            contador = contador + 1
                        j = 0
                        while (contador + j) <= (size - 1) and matriz[contador + j][pos] != self.diccionario_antiguo[
                            "*"]:
                            j = j + 1
                        for i in range(len(fincad)):
                            matriz[contador + j - 1 - i][pos] = self.diccionario_antiguo[fincad[len(fincad) - 1 - i]]
                    else:
                        contador = 0
                        while contador <= (size - 1) and matriz[0 + contador][pos] != self.diccionario_antiguo["*"]:
                            contador = contador + 1
                        for i in range(len(fincad)):
                            matriz[contador - 1 - i][pos] = self.diccionario_antiguo[fincad[len(fincad) - 1 - i]]
                else:
                    contador = 0
                    while matriz[lugar[cont - 1] + contador][pos] == self.diccionario_antiguo["*"]:
                        contador = contador + 1
                    j = 0
                    while (lugar[cont - 1] + contador + j) <= (size - 1) and matriz[lugar[cont - 1] + contador + j][
                        pos] != self.diccionario_antiguo["*"]:
                        j = j + 1
                    for i in range(len(fincad)):
                        matriz[lugar[cont - 1] + contador + j - 1 - i][pos] = self.diccionario_antiguo[
                            fincad[len(fincad) - 1 - i]]


        elif inp == "I":
            if bucle == 0:
                for r in range(size):
                    matriz[pos][r] = self.diccionario_antiguo["."]
            for r in range(len(lugar)):
                matriz[pos][lugar[r]] = self.diccionario_antiguo["*"]
            if len(lugar) == 0:
                for i in range(len(fincad)):
                    matriz[pos][i] = self.diccionario_antiguo[fincad[i]]
            else:
                if bucle == 0:
                    contador = 0
                    while matriz[pos][0 + contador] == self.diccionario_antiguo["*"]:
                        contador = contador + 1
                    for i in range(len(fincad)):
                        matriz[pos][contador + i] = self.diccionario_antiguo[fincad[i]]
                else:
                    contador = 0
                    while (lugar[cont - 1] + contador) <= (size - 1) and matriz[pos][lugar[cont - 1] + contador] == \
                            self.diccionario_antiguo["*"]:
                        contador = contador + 1
                    for i in range(len(fincad)):
                        matriz[pos][lugar[cont - 1] + contador + i] = self.diccionario_antiguo[fincad[i]]

        elif inp == "D":
            if bucle == 0:
                for r in range(size):
                    matriz[pos][r] = self.diccionario_antiguo["."]
            for r in range(len(lugar)):
                matriz[pos][lugar[r]] = self.diccionario_antiguo["*"]
            if len(lugar) == 0:
                for i in range(len(fincad)):
                    matriz[pos][size - 1 - i] = self.diccionario_antiguo[fincad[len(fincad) - 1 - i]]
            else:
                if bucle == 0:
                    if lugar[0] == 0:
                        contador = 0
                        while matriz[pos][0 + contador] == self.diccionario_antiguo["*"]:
                            contador = contador + 1
                        j = 0
                        while (contador + j) <= (size - 1) and matriz[pos][contador + j] != self.diccionario_antiguo[
                            "*"]:
                            j = j + 1
                        for i in range(len(fincad)):
                            matriz[pos][contador + j - 1 - i] = self.diccionario_antiguo[fincad[len(fincad) - 1 - i]]
                    else:
                        contador = 0
                        while contador <= (size - 1) and matriz[pos][0 + contador] != self.diccionario_antiguo["*"]:
                            contador = contador + 1
                        for i in range(len(fincad)):
                            matriz[pos][contador - 1 - i] = self.diccionario_antiguo[fincad[len(fincad) - 1 - i]]
                else:
                    contador = 0
                    while matriz[pos][lugar[cont - 1] + contador] == self.diccionario_antiguo["*"]:
                        contador = contador + 1
                    j = 0
                    while (lugar[cont - 1] + contador + j) <= (size - 1) and matriz[pos][
                        lugar[cont - 1] + contador + j] != self.diccionario_antiguo["*"]:
                        j = j + 1
                    for i in range(len(fincad)):
                        matriz[pos][lugar[cont - 1] + contador + j - 1 - i] = self.diccionario_antiguo[
                            fincad[len(fincad) - 1 - i]]

    """
     En este proceso lo que realizamos es según el movimiento indicado, introducir los valores que formaran la nueva matriz.
     Lo primero que haremos será limpiar la matriz y llenar los huecos que tenian asteriscos haciendo caso del lugar donde estaban.
     Lo siguiente sera introducir las cadenas. Para ello distinguimos si es sin asteriscos o con ellos, ya que en el primer caso
     no debemos tener "cuidado" de las posiciones iniciales de las cadenas. En cuanto al segundo caso mediante desarollamos un algoritmo
     mediante el cual comprueba si se trata de la primera cadena u otra. Si es la primera empezamos a introducir los valores de esta justo
     tras los asteriscos pertinentes( para lo cual desarrollamos un contador para saber la poscion exacta donde empezar).Sino se trata de
     la primera cadena con otro contador de nuevo contamos desde la ultima posicion del asterisco correspondiente al indice que traemos
     por entrada. Y posteriormente esa cadeana la introducimos a partir de ese indica mas el contador.
     Parametros de entrada:la matriz,su tamano,lista con el lugar de los *,diccionario actual, la columna o fila donde se deben introducir,
# end of class MyApp

if __name__ == "__main__":
    app = MyApp(0)
    app.MainLoop()

     el contador de la cadena una vez separada tras los * y el otro contador que almacena el anterior pero sin contar donde la posicion del
     vector sea "".
     Salida: modifica los valores de la matriz a imprimir
    """

    def comparar(self, matriz, matriz_comparar, size):
        iguales = True
        for r in range(size):
            for c in range(size):
                if (matriz[r][c] != matriz_comparar[r][c]):
                    iguales = False

        return iguales

    """
     Esta funcion lo que hace es comparar si las dos matrices de entrada: la que teniamos comparada con la actualizada tras el movimiento
     Si son iguales en todos los elementos devuelve True, sino False.
     Precondicion: Las dos matrices tienen el mismo tamano
     Parametros de entrada:la matriz antigua y la actual y su tamaño
     Salida: boolean que nos indicara si todos sus elementos son iguales

"""


# end of class MiVentana

class MyApp(wx.App):
    def OnInit(self):
        self.frame_20148 = MiVentana(None, wx.ID_ANY, "")
        self.SetTopWindow(self.frame_20148)
        self.frame_20148.Show()
        return True


# end of class MyApp

if __name__ == "__main__":
    app = MyApp(0)
    app.MainLoop()
